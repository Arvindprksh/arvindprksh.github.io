---
layout: post
title: Development Diary
subtitle: When I have to develop IOCTL, I write what I think
css:
tags:
date:
big-image:
share-image:
permalink:
comments:
show-share:
big-image:
meta-title:
meta-description:
---

3/7/2016
kernel 4.4가 부팅이 안되어 재 컴파일 및 모듈을 빌드해서 재설치했더니, 갑자기 잡히던 nvme 장치가 ㅜㅜ 안된다. 

어찌해야하 하나 고민을 하다가 결국 다시 커널 컴파일 및 모듈을 빌드 하고 설치 하고 그리고 나서 insmod 및 modprobe해도 

안되었다. 그래서 lsmod로 현재 움직이 작동중인 모드를 검사를 했는데 nvme이 잡힌다 ㅜㅜ 

무슨 문제일까 하다가 계속 고민하다가 dmesg | grep nvme으로 검사를 했더니 문제점 발견 선배한테 안 물어 봤으면 

이걸로 이틀은 고생했을 듯 ㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜ 그래서 에러를 발견했다 그것은

바로 내가 커널 소스를 고쳐서 제대로 초기화가 안되도록 설정이 해놓은 것 ㅜㅜ 이거 진짜 몇일동안 밤샜을 지도 ㅜㅜ

그래서 커널 소스 다시 수정을 하고 다시 커널 및 모듈을 빌드 하고 재설치 하니 이제 제대로 pci로 꽂은 ssd가 인식이 된다. 

--------------이제 open channel SSD를 한번 테스트 해봐야 겠다.  겨우 진도 나가네 ㅜㅜㅜ 

정말 리눅스 ㅜㅜ

3/8/ 2016

이제야 open channel ssd open source에 대한 이해력이 커지는 거 같다. 엤날에 커널을 하고 나서 안하고 있었는데

이제야 커널에 대하여 특히PCI, serial ATA등을 이해 할 수 있을 것 같다. 그냥 메인보드에 연렬하고 데이터를 전송하는 방법이 다를 

뿐이다. 너무 깊게 알려고 할려면 난 전자과 가서 회로 설계 이론을 공부해야 할듯 현재 open channel SSD를 이용하기 위해서는 SSD가 
PCI를 이용해서 접근을 해야한다. 즉 맨 처음에 PCI를 통해 SSD에 접근 할 수 있도로 제공 해주는 nvme라는 논리적인 인터페이스를 

이용을 해야겠다. 이를 이용하여 오늘은 내가 꽂은 SSD의 인식 값을 조사 하고 디버깅을 하고 있는 중이다. 그리고 인식을 해서 

open channel SSD 소스와 호환이 되는 지 작업을 하고 있다. 


진짜 오랜만에 커널을 디버깅해보는 것 같다. 진짜 -----------;;;

일단 현재 해야할 일은 내가 가진 SSD가 open channel SSD을 사용 할 수 있는 세팅이 되는지 등록이 되는 지 확인하는 단계 


3/10 /2016

도대체 문제가 무엇일까 ??? 문제가 되는 시점이 있는데 도대 체 잘 모르겠다. 자꾸 자기 멋대로 

커널이 업데이트 되고 또, 갑자기 되던 디버깅이 안되는 것은 무엇이 문제일까?

그리고 잡히던 SSD는 또 왜 ㅜㅜ

3/14/2016

아 작업하던거 날라 갔어 젠장,  어쩌지 젠장 이거 복원을 해야 하는데 정말 어쩌지 

일단 그동안 문제점 좀 생각을 해보자 

1. 자꾸 커널이 되던게 안된다. 

2. 어느 소스 부분이 문제인지 디버깅을 통해 알 수 있었다.

3/15/2016

처음 부터 커널 설치 Centos7을 다시 설치를 하고 시작을 해야 겠다. 

일단.

https://www.kernel.org/에서 인정한 안정된 커널 버전으로 시작을 해야 겠다. 

초기 sudo권한 설정, 및 컴파일 하는 법을 일단은 다시 숙지 

세팅을 다시 하자 

아 어제 리눅스를 안정버전 및 그냥 4.4최종 버전으로 했는데 4.4최종 버전으로 해도 

SSD가 제대로 인식이 되었다. 이유를 알아보니 tar.xz 라는 압축을 tar만으로 풀고 

xz를 못풀어서 문제가 된거 같다. 

그런데 어제 계속 컴파일을 하고 디버깅을 위해  프린트k를 사용을 했는데 문제가 발생을 

한다. 그냥 순수로 커널을 빌드하면 이상이 없고, 단지 printk만 했는데 문제가 발생하는 이유는 무엇일까??

그래서 여러 테스트 결과 문제점을 발견한거 같다.  빌드 하기전 빌드 환경설정 make menuconfig문제가 겹친듯 하다.

이제 이것을 해결하고 집중적을 디버깅 및 테스트 및 코드 수정을 작업을 할 수 있을 거 같다. 

기분 겁나게 좋다. 와 드디어 문제 해결 또 했다. ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 이것때문에 맨날 집에 늦가 가지만 그래도 좋다 

압축은 

xz -cd linux-4.X.tar.xz | tar xvf - 이 명령어 까먹지 마 

그리고 

make menuconfig에서  load before configuration. 

then complie your kernel 

3/16/2016


이제 드디어 ioctl를 할 수 있을 지도 

--------------------------------------------------------------------------------

3/29/2016

오 드디어 작업을 일지 쓸 수 있는 여유가 생겼네......

이놈의 lihgtnvm, open channel SSD 그동안 커널에서 문제가 있는 줄 알고 일주일 동안

계속 커널 디버깅만 하고 ㅜㅜㅜ 

이미 PCI 기반의 ssd에 관한 ioctl은 /dev/lightnvm/control로 해서 lightnvm의 디바이스가 인식이 될 준비가 되었는지 확인을 하고 

그리고 /dev/lightnvm/control 에 ioctl의 명령을 때리면 된다. 

하지만 중요한 국면이 있는데 시스템 콜을 user space에서 명령을 할때 명령후 얻을 데이터의 메모리 공간의 주소도 같이 넘겨 주어야 한다. 

이런한 작업은 금방 한다 그리고 /linux/include/uapi/linux/lightnvm.h의 파일을 의 데이터 자료형을 

알아야 하기 때문에  ioctl함수를 이용할려고 할때 위의 헤더파일의 내용을 복사해서 

헤더파일로 만들어야 한다. 

이렇게 해서 리눅스 디바이스에 시스템 콜을 날렸다. 


하지만 생각했던 내가 설치한 SSD의 정보가 안날라와서 무슨 문제인가 고민을 하기 시작했다. 

그랬더니 문제는 centos 7.1에서 리눅스 커널 버전 4.4.6 , 4.4, 4.5에 lightnvm이 적용되어 있는 커널을 

다비교하기 시작하고 해도 커널에서 SSD를 인식을 못하는 것이었다. 

즉 /dev에서 nvme0라고 해서 SSD of pci는 인식은 하는데 이를 통해서 커널의 blockdevice를 생성하지 않고 있던 것이다. 

이로인에 계속 고민을 하고 한 결과, nvme express 1.2 specification을 확인을 하기로 했다. 그 이유는 커널 코드를 

디버깅을 한 결과 특정 함수에서 반환을 하는 값이 nvm express status code이기 때문에 어떤 오류인지 확인을 했다.

그리고 opcode도 이상 한 거 같아 확인을 위해 usb uart의 serial port를 이용해서 오류를 확인 하기로 했다. 

확인을 해보니 pci 표준에 맞지 않는 opcode이다. 지원되지 않는 opcode라는 오류를 발견하게 되었다. 

즉 현재 커널 최신 버전에 들어간 host가 SSD를 직접 통제하는 시스템은 특정 장치만 이용이 가능하게 

자기만의 pci 규정을 사용하고 있는 것이다. 

그럼 이문제를 어떻게 해결을 해야 할까?????????

커널을 가지고 와서 내 SSD 에 맞게 수정을 하는 작업을 진행해야 하는데 ........

-------------------------------------------------------------------------------

3/30/2016 

오늘 드디어 open channeel SSD 와 lightnvm의 테스트 확인 작업이 마무리가 되었다. 

와~~~~~~~  lightnvm이 특정 pci 보드만 사용이 가능하도록 했기때문에 

내 pci 보드에 SSD를 넣어서 Lightnvm을 이용하기가 힘들었다. 그래서 이 작업은 이제 

다른 방식으로 해보고 이제 부터는 rocksDB와 revelDB를 하게 되었다. ㅋㅋㅋㅋㅋ

다른 미션이다 ㅋㅋㅋㅋ 이제 일단 먼저 levelDB를 가지고 SSD 성능 테스트를 해야 한다.

즉 benchmarking을 해야 한다. 
