


## [NVMe-Cli](https://github.com/linux-nvme/nvme-cli)

Now, I'm looking at commit version,**"0142aebd1125ae33cdf60fa957a8bfef5851a76e"**, on master brach, 

This tool is for NVMe device and open-source. 

I have seen this tool before to make VU command. 

but Now, when I look at this tools again. I need to understand this code to make new VU command of NVMe SSD. 

So in the latest version with the above commit number, everything is new. 

because, nvme-cli tool supports fabric and lightNVM. 

So I analyze structure of the source code to make operation of VU command. 

after finishing analysis, I think it was easy to find out where I change the open-source.

If you want to add operation, You just have to change those files.

## At first, nvme-builtin.h 

```c
#undef CMD_INC_FILE 
#define CMD_INC_FILE nvme-builtin 
 
#if !defined(NVME_BUILTIN) || defined(CMD_HEADER_MULTI_READ) 
#define NVME_BUILTIN 
 
#include "cmd.h" 
 
COMMAND_LIST( 
        ENTRY("list", "List all NVMe devices and namespaces on machine", list) 
        ENTRY("id-ctrl", "Send NVMe Identify Controller", id_ctrl) 
        ENTRY("id-ns", "Send NVMe Identify Namespace, display structure", id_ns) 
        ENTRY("list-ns", "Send NVMe Identify List, display structure", list_ns) 
        ENTRY("create-ns", "Creates a namespace with the provided parameters", create_ns) 
        ENTRY("delete-ns", "Deletes a namespace from the controller", delete_ns) 
        ENTRY("attach-ns", "Attaches a namespace to requested controller(s)", attach_ns) 
        ENTRY("detach-ns", "Detaches a namespace from requested controller(s)", detach_ns) 
        ENTRY("list-ctrl", "Send NVMe Identify Controller List, display structure", list_ctrl) 
        ENTRY("get-ns-id", "Retrieve the namespace ID of opened block device", get_ns_id) 
        ENTRY("get-log", "Generic NVMe get log, returns log in raw format", get_log) 
        ENTRY("fw-log", "Retrieve FW Log, show it", get_fw_log) 
        ENTRY("smart-log", "Retrieve SMART Log, show it", get_smart_log) 
        ENTRY("error-log", "Retrieve Error Log, show it", get_error_log) 
        ENTRY("get-feature", "Get feature and show the resulting value", get_feature) 
        ENTRY("set-feature", "Set a feature and show the resulting value", set_feature) 
        ENTRY("format", "Format namespace with new block format", format) 
        ENTRY("fw-activate", "Activate new firmware slot", fw_activate) 
        ENTRY("fw-download", "Download new firmware", fw_download) 
        ENTRY("admin-passthru", "Submit arbitrary admin command, return results", admin_passthru) 
        ENTRY("io-passthru", "Submit an arbitrary IO command, return results", io_passthru) 
        ENTRY("security-send", "Submit a Security Send command, return results", sec_send) 
        ENTRY("security-recv", "Submit a Security Receive command, return results", sec_recv) 
        ENTRY("resv-acquire", "Submit a Reservation Acquire, return results", resv_acquire) 
        ENTRY("resv-register", "Submit a Reservation Register, return results", resv_register) 
        ENTRY("resv-release", "Submit a Reservation Release, return results", resv_release) 
        ENTRY("resv-report", "Submit a Reservation Report, return results", resv_report) 
        ENTRY("dsm", "Submit a Data Set Management command, return results", dsm) 
        ENTRY("flush", "Submit a Flush command, return results", flush) 
        ENTRY("compare", "Submit a Compare command, return results", compare) 
        ENTRY("read", "Submit a read command, return results", read_cmd) 
        ENTRY("write", "Submit a write command, return results", write_cmd) 
        ENTRY("write-zeroes", "Submit a write zeroes command, return results", write_zeroes) 
        ENTRY("write-uncor", "Submit a write uncorrectable command, return results", write_uncor) 
        ENTRY("reset", "Resets the controller", reset) 
        ENTRY("subsystem-reset", "Resets the controller", subsystem_reset) 
        ENTRY("show-regs", "Shows the controller registers. Requires admin character device", show_registers) 
        ENTRY("discover", "Discover NVMeoF subsystems", discover_cmd) 
        ENTRY("connect-all", "Discover and Connect to NVMeoF subsystems", connect_all_cmd) 
        ENTRY("connect", "Connect to NVMeoF subsystem", connect_cmd) 
        ENTRY("disconnect", "Disconnect from NVMeoF subsystem", disconnect_cmd) 
); 
 
#endif 
 
#include "define_cmd.h"
```


## Second, nvme.c 

```c
static int get_smart_log(int argc, char **argv, struct command *cmd, struct plugin *plugin)
{
        struct nvme_smart_log smart_log;
        const char *desc = "Retrieve SMART log for the given device "\
                        "(or optionally a namespace) in either decoded format "\
                        "(default) or binary.";
        const char *namespace = "(optional) desired namespace";
        const char *raw = "output in binary format";
        int err, fmt, fd;

        struct config {
                __u32 namespace_id;
                int   raw_binary;
                char *output_format;
        };

        struct config cfg = {
                .namespace_id = 0xffffffff,
                .output_format = "normal",
        };

        const struct argconfig_commandline_options command_line_options[] = {
                {"namespace-id",  'n', "NUM", CFG_POSITIVE, &cfg.namespace_id,  required_argument, namespace},
                {"output-format", 'o', "FMT", CFG_STRING,   &cfg.output_format, required_argument, output_format },
                {"raw-binary",    'b', "",    CFG_NONE,     &cfg.raw_binary,    no_argument,       raw},
                {NULL}
        };

        fd = parse_and_open(argc, argv, desc, command_line_options, &cfg, sizeof(cfg));
        if (fd < 0)
                return fd;

        fmt = validate_output_format(cfg.output_format);
        if (fmt < 0)
                return fmt;
        if (cfg.raw_binary)
                fmt = BINARY;

        err = nvme_smart_log(fd, cfg.namespace_id, &smart_log);
        if (!err) {
                if (fmt == BINARY)
                        d_raw((unsigned char *)&smart_log, sizeof(smart_log));
                else if (fmt == JSON)
                        json_smart_log(&smart_log, cfg.namespace_id, devicename);
                else
                        show_smart_log(&smart_log, cfg.namespace_id, devicename);
        }
        else if (err > 0)
                fprintf(stderr, "NVMe Status:%s(%x)\n",
                                        nvme_status_to_string(err), err);
        else
                perror("smart log");
        return err;
}
```

From now on, just function to print 

## Third, nvme-print.h

```c
#ifndef NVME_PRINT_H
#define NVME_PRINT_H

#include "nvme.h"
#include <inttypes.h>

enum {
        TERSE = 0x1u,   // only show a few useful fields
        HUMAN = 0x2u,   // interpret some values for humans
        VS    = 0x4u,   // print vendor specific data area
        RAW   = 0x8u,   // just dump raw bytes
};

void d(unsigned char *buf, int len, int width, int group);
void d_raw(unsigned char *buf, unsigned len);

uint64_t int48_to_long(__u8 *data);

void __show_nvme_id_ctrl(struct nvme_id_ctrl *ctrl, unsigned int mode, void (*vendor_show)(__u8 *vs));
void show_nvme_id_ctrl(struct nvme_id_ctrl *ctrl, unsigned int mode);
void show_nvme_id_ns(struct nvme_id_ns *ns, unsigned int flags);
void show_nvme_resv_report(struct nvme_reservation_status *status);
void show_lba_range(struct nvme_lba_range_type *lbrt, int nr_ranges);
void show_error_log(struct nvme_error_log_page *err_log, int entries, const char *devname);
void show_intel_smart_log(struct nvme_additional_smart_log *smart, unsigned int nsid, const char *devname);
void show_smart_log(struct nvme_smart_log *smart, unsigned int nsid, const char *devname);
void show_fw_log(struct nvme_firmware_log_page *fw_log, const char *devname);
void show_ctrl_registers(void *bar, unsigned int mode);

void nvme_feature_show_fields(__u32 fid, unsigned int result, unsigned char *buf);
char *nvme_status_to_string(__u32 status);
char *nvme_select_to_string(int sel);
char *nvme_feature_to_string(int feature);

void json_nvme_id_ctrl(struct nvme_id_ctrl *ctrl, unsigned int mode);
void json_nvme_id_ns(struct nvme_id_ns *ns, unsigned int flags);
void json_nvme_resv_report(struct nvme_reservation_status *status);
void json_error_log(struct nvme_error_log_page *err_log, int entries, const char *devname);
void json_smart_log(struct nvme_smart_log *smart, unsigned int nsid, const char *devname);
void json_add_smart_log(struct nvme_additional_smart_log *smart,
                        unsigned int nsid, const char *devname);
void json_fw_log(struct nvme_firmware_log_page *fw_log, const char *devname);
void json_print_list_items(struct list_item *items, unsigned amnt);


#endif
```

## Addtionally, nvme-print.c file 

finally, IF you change this file. you can make nvme-cli tool to support VU command. 

**be careful, what I am saying is what version of NVMe-cli, because later on, version will be changed.**


**BUT**, If you want to support man operation of linux. you need a little more

let's make a code for VU command 
